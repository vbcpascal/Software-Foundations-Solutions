<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="common/css/sf.css" rel="stylesheet" type="text/css" />
    <link href="common/css/alert.css" rel="stylesheet" type="text/css" />
    <link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
    <script src="common/jquery-ui/external/jquery/jquery.js"></script>
    <script src="common/jquery-ui/jquery-ui.js"></script>
    <script src="common/toggleproofs.js"></script>
    <link href="common/css/lf.css" rel="stylesheet" type="text/css" />

    <!-- gittalk -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>

    <title> IndPrinciples </title>
</head>

<div id="page">

    <div id="header">
        <div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
                <img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
        <div class='booktitleinheader'><a href='index.html'>Volume 1: Logical Foundations</a></div>
        <ul id='menu'>
            <li class='section_name'><a href="index.html">Main Page</a></li>
            <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
            <li class='section_name'><a href='coqindex.html'>Index</a></li>
            <li class='section_name'><a href='deps.html'>Roadmap</a></li>
        </ul>
    </div>

    <div id="main">
<h1 class="libtitle">IndPrinciples<span class="subtitle">Induction Principles</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>

 With the Curry-Howard correspondence and its realization in Coq in
    mind, we can now take a deeper look at induction principles. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Warnings</span> "-notation-overridden,-parsing".<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">LF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">ProofObjects</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Basics</h1>

<div class="paragraph"> </div>

 Every time we declare a new <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> datatype, Coq
    automatically generates an <i>induction principle</i> for this type.
    This induction principle is a theorem like any other: If <span class="inlinecode"><span class="id" title="var">t</span></span> is
    defined inductively, the corresponding induction principle is
    called <span class="inlinecode"><span class="id" title="var">t_ind</span></span>.  Here is the one for natural numbers: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
In English: Suppose <span class="inlinecode"><span class="id" title="var">P</span></span> is a property of natural numbers (that is,
      <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is a <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> for every <span class="inlinecode"><span class="id" title="var">n</span></span>). To show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds of all
      <span class="inlinecode"><span class="id" title="var">n</span></span>, it suffices to show:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode">0</span>

</li>
<li> for any <span class="inlinecode"><span class="id" title="var">n</span></span>, if <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">n</span></span>, then <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic is a straightforward wrapper that, at its
    core, simply performs <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">t_ind</span></span>.  To see this more clearly,
    let's experiment with directly using <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">nat_ind</span></span>, instead of
    the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic, to carry out some proofs.  Here, for
    example, is an alternate proof of a theorem that we saw in the
    <span class="inlinecode"><span class="id" title="keyword">Induction</span></span> chapter. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_r'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> * 0 = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n'</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This proof is basically the same as the earlier one, but a
    few minor differences are worth noting.

<div class="paragraph"> </div>

    First, in the induction step of the proof (the <span class="inlinecode"><span class="id" title="var">S</span></span> case), we
    have to do a little bookkeeping manually (the <span class="inlinecode"><span class="id" title="tactic">intros</span></span>) that
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> does automatically.

<div class="paragraph"> </div>

    Second, we do not introduce <span class="inlinecode"><span class="id" title="var">n</span></span> into the context before applying
    <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> -- the conclusion of <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> is a quantified formula,
    and <span class="inlinecode"><span class="id" title="tactic">apply</span></span> needs this conclusion to exactly match the shape of
    the goal state, including the quantifier.  By contrast, the
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic works either with a variable in the context or
    a quantified variable in the goal.

<div class="paragraph"> </div>

    Third, we had to manually supply the name of the induction principle
    with <span class="inlinecode"><span class="id" title="tactic">apply</span></span>, but <span class="inlinecode"><span class="id" title="tactic">induction</span></span> figures that out itself.

<div class="paragraph"> </div>

    These conveniences make <span class="inlinecode"><span class="id" title="tactic">induction</span></span> nicer to use in practice than
    applying induction principles like <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> directly.  But it is
    important to realize that, modulo these bits of bookkeeping,
    applying <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> is what we are really doing. 
<div class="paragraph"> </div>

<a name="lab2"></a><h4 class="section">Exercise: 2 stars, standard (plus_one_r')</h4>


<div class="paragraph"> </div>

    Complete this proof without using the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_one_r'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + 1 = <span class="id" title="var">S</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
</div><div class="solution"><div> 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
</div></div><div class="doc">  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Coq generates induction principles for every datatype
    defined with <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, including those that aren't recursive.
    Although of course we don't need the proof technique of induction
    to prove properties of non-recursive datatypes, the idea of an
    induction principle still makes sense for them: it gives a way to
    prove that a property holds for all values of the type. 
<div class="paragraph"> </div>

 These generated principles follow a similar pattern. If we
    define a type <span class="inlinecode"><span class="id" title="var">t</span></span> with constructors <span class="inlinecode"><span class="id" title="var">c1</span></span> ... <span class="inlinecode"><span class="id" title="var">cn</span></span>, Coq generates a
    theorem with this shape:

<div class="paragraph"> </div>

    t_ind : forall P : t -&gt; Prop,
              ... case for c1 ... -&gt;
              ... case for c2 ... -&gt; ...
              ... case for cn ... -&gt;
              forall n : t, P n

<div class="paragraph"> </div>

    The specific shape of each case depends on the arguments to the
    corresponding constructor. 
<div class="paragraph"> </div>

 Before trying to write down a general rule, let's look at
    some more examples. First, an example where the constructors take
    no arguments: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">time</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">night</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">time_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="var">time</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">day</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">night</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span> : <span class="id" title="var">time</span>, <span class="id" title="var">P</span> <span class="id" title="var">t</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h4 class="section">Exercise: 1 star, standard, optional (rgb)</h4>


<div class="paragraph"> </div>

    Write out the induction principle that Coq will generate for the
    following datatype.  Write down your answer on paper or type it
    into a comment, and then compare it with what Coq prints. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">rgb</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="tactic">red</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">green</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">blue</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">rgb_ind</span>.<br/>

<br/>
</div>

<div class="doc">
</div><div class="solution-text"><div>  rgb_ind : 
      forall P : rgb -&gt; Prop,
      P red -&gt; P green -&gt; P blue -&gt;
      forall r : rgb, P r 
 </div></div><div class="doc"> 
<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

 Here's another example, this time with one of the constructors
    taking some arguments. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natlist</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">nnil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">ncons</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>).<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">natlist_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="var">natlist</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">nnil</span>  -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">l</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">ncons</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span>.<br/>

<br/>
</div>

<div class="doc">
In general, the automatically generated induction principle for
    inductive type <span class="inlinecode"><span class="id" title="var">t</span></span> is formed as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Each constructor <span class="inlinecode"><span class="id" title="var">c</span></span> generates one case of the principle.

</li>
<li> If <span class="inlinecode"><span class="id" title="var">c</span></span> takes no arguments, that case is:

<div class="paragraph"> </div>

      "P holds of c"

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode"><span class="id" title="var">c</span></span> takes arguments <span class="inlinecode"><span class="id" title="var">x1</span>:<span class="id" title="var">a1</span></span> ... <span class="inlinecode"><span class="id" title="var">xn</span>:<span class="id" title="var">an</span></span>, that case is:

<div class="paragraph"> </div>

      "For all x1:a1 ... xn:an,
          if <span class="inlinecode"><span class="id" title="var">P</span></span> holds of each of the arguments of type <span class="inlinecode"><span class="id" title="var">t</span></span>,
          then <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">xn</span></span>"

<div class="paragraph"> </div>

      But that oversimplifies a little.  An assumption about <span class="inlinecode"><span class="id" title="var">P</span></span>
      holding of an argument <span class="inlinecode"><span class="id" title="var">x</span></span> of type <span class="inlinecode"><span class="id" title="var">t</span></span> actually occurs
      immediately after the quantification of <span class="inlinecode"><span class="id" title="var">x</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

 For example, suppose we had written the definition of <span class="inlinecode"><span class="id" title="var">natlist</span></span> a little
    differently: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natlist'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">nnil'</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nsnoc</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist'</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>).<br/>

<br/>
</div>

<div class="doc">
Now the induction principle case for <span class="inlinecode"><span class="id" title="var">nsnoc1</span></span> is a bit different
    than the earlier case for <span class="inlinecode"><span class="id" title="var">ncons</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">natlist'_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="var">natlist'</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">nnil'</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist'</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> (<span class="id" title="var">nsnoc</span> <span class="id" title="var">l</span> <span class="id" title="var">n</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">natlist'</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab4"></a><h4 class="section">Exercise: 1 star, standard (booltree_ind)</h4>


<div class="paragraph"> </div>

    In the comment below, Write out the induction principle that Coq 
    will generate for the following datatype. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">booltree</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;| <span class="id" title="var">bt_empty</span><br/>
&nbsp;| <span class="id" title="var">bt_leaf</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>)<br/>
&nbsp;| <span class="id" title="var">bt_branch</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> : <span class="id" title="var">booltree</span>).<br/>

<br/>
</div>

<div class="doc">
</div><div class="solution-text"><div>  booltree_ind : 
      forall P : booltree -&gt; Prop,
        P bt_empty -&gt;
        (forall (b : bool), P (bt_leaf b)) -&gt;
        (forall (b : bool) (t1 : booltree), P t1 -&gt; 
           forall (t2 : booltree), P t2 -&gt;
             P (bt_branch b t1 t2)) -&gt;
        forall b : booltree, P b
 </div></div><div class="doc"> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_booltree_ind</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>*<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab5"></a><h4 class="section">Exercise: 1 star, standard (toy_ind)</h4>


<div class="paragraph"> </div>

    Here is an induction principle for a toy type:

<div class="paragraph"> </div>

  forall P : Toy -&gt; Prop,
    (forall b : bool, P (con1 b)) -&gt;
    (forall (n : nat) (t : Toy), P t -&gt; P (con2 n t)) -&gt;
    forall t : Toy, P t

<div class="paragraph"> </div>

    Give an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definition of <span class="inlinecode"><span class="id" title="var">Toy</span></span>, such that the induction
    principle Coq generates is that given above: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Toy</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;</div>

<div class="doc">
</div><div class="solution"><div> 
</div>
<div class="code">
&nbsp;&nbsp;| <span class="id" title="var">con1</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">con2</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">Toy</span>)<br/>
&nbsp;&nbsp;</div>

<div class="doc">
</div></div><div class="doc"> 
</div>
<div class="code">
&nbsp;&nbsp;.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">manual_grade_for_toy_ind</span> : <span class="id" title="var">option</span> (<span class="id" title="var">nat</span>*<span class="id" title="var">string</span>) := <span class="id" title="var">None</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h1 class="section">Polymorphism</h1>

<div class="paragraph"> </div>

 What about polymorphic datatypes?

<div class="paragraph"> </div>

    The inductive definition of polymorphic lists

<div class="paragraph"> </div>

      Inductive list (X:Type) : Type :=
        | nil : list X
        | cons : X -&gt; list X -&gt; list X.

<div class="paragraph"> </div>

    is very similar to that of <span class="inlinecode"><span class="id" title="var">natlist</span></span>.  The main difference is
    that, here, the whole definition is <i>parameterized</i> on a set <span class="inlinecode"><span class="id" title="var">X</span></span>:
    that is, we are defining a <i>family</i> of inductive types <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>,
    one for each <span class="inlinecode"><span class="id" title="var">X</span></span>.  (Note that, wherever <span class="inlinecode"><span class="id" title="var">list</span></span> appears in the body
    of the declaration, it is always applied to the parameter <span class="inlinecode"><span class="id" title="var">X</span></span>.)

<div class="paragraph"> </div>

  The induction principle is likewise parameterized on <span class="inlinecode"><span class="id" title="var">X</span></span>:

<div class="paragraph"> </div>

      list_ind :
        forall (X : Type) (P : list X -&gt; Prop),
           P <font size=-2>&#9744;</font> -&gt;
           (forall (x : X) (l : list X), P l -&gt; P (x :: l)) -&gt;
           forall l : list X, P l

<div class="paragraph"> </div>

    Note that the <i>whole</i> induction principle is parameterized on
    <span class="inlinecode"><span class="id" title="var">X</span></span>.  That is, <span class="inlinecode"><span class="id" title="var">list_ind</span></span> can be thought of as a polymorphic
    function that, when applied to a type <span class="inlinecode"><span class="id" title="var">X</span></span>, gives us back an
    induction principle specialized to the type <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>. 
<div class="paragraph"> </div>

<a name="lab7"></a><h4 class="section">Exercise: 1 star, standard, optional (tree)</h4>


<div class="paragraph"> </div>

    Write out the induction principle that Coq will generate for
   the following datatype.  Compare your answer with what Coq
   prints. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">tree</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">leaf</span> (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">node</span> (<span class="id" title="var">t1</span> <span class="id" title="var">t2</span> : <span class="id" title="var">tree</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">tree_ind</span>.<br/>

<br/>
</div>

<div class="doc">
</div><div class="solution-text"><div>  tree_ind : 
      forall (X : Type) (P : tree X -&gt; Prop),
        (forall (x : X), P (leaf X x)) -&gt;
        (forall (t1 : tree X), P t1 -&gt; 
           forall (t2 : tree X), P t2 -&gt;
             P (node X t1 t2)) -&gt;
      forall t : tree X, P t
 </div></div><div class="doc"> 
<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab8"></a><h4 class="section">Exercise: 1 star, standard, optional (mytype)</h4>


<div class="paragraph"> </div>

    Find an inductive definition that gives rise to the
    following induction principle:

<div class="paragraph"> </div>

      mytype_ind :
        forall (X : Type) (P : mytype X -&gt; Prop),
            (forall x : X, P (constr1 X x)) -&gt;
            (forall n : nat, P (constr2 X n)) -&gt;
            (forall m : mytype X, P m -&gt;
               forall n : nat, P (constr3 X m n)) -&gt;
            forall m : mytype X, P m

<div class="paragraph"> </div>

 </div><div class="solution"><div> 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">mytype</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) :=<br/>
| <span class="id" title="var">constr1</span> (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>)<br/>
| <span class="id" title="var">constr2</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
| <span class="id" title="var">constr3</span> (<span class="id" title="var">m</span> : <span class="id" title="var">mytype</span> <span class="id" title="var">X</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">mytype_ind</span>.<br/>
</div>

<div class="doc">
</div></div><div class="doc"> 
<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab9"></a><h4 class="section">Exercise: 1 star, standard, optional (foo)</h4>


<div class="paragraph"> </div>

    Find an inductive definition that gives rise to the
    following induction principle:

<div class="paragraph"> </div>

      foo_ind :
        forall (X Y : Type) (P : foo X Y -&gt; Prop),
             (forall x : X, P (bar X Y x)) -&gt;
             (forall y : Y, P (baz X Y y)) -&gt;
             (forall f1 : nat -&gt; foo X Y,
               (forall n : nat, P (f1 n)) -&gt; P (quux X Y f1)) -&gt;
             forall f2 : foo X Y, P f2
 </div><div class="solution"><div> 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">foo</span> (<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="keyword">Type</span>) :=<br/>
| <span class="id" title="var">bar</span> (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>)<br/>
| <span class="id" title="var">baz</span> (<span class="id" title="var">y</span> : <span class="id" title="var">Y</span>)<br/>
| <span class="id" title="var">quux</span> (<span class="id" title="var">f1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">foo</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)<br/>
.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">foo_ind</span>.<br/>
</div>

<div class="doc">
</div></div><div class="doc">  <font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a name="lab10"></a><h4 class="section">Exercise: 1 star, standard, optional (foo')</h4>


<div class="paragraph"> </div>

    Consider the following inductive definition: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">foo'</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">C1</span> (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">foo'</span> <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">C2</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">foo'_ind</span>.<br/>

<br/>
</div>

<div class="doc">
What induction principle will Coq generate for <span class="inlinecode"><span class="id" title="var">foo'</span></span>?  Fill
   in the blanks, then check your answer with Coq.)

<div class="paragraph"> </div>

     foo'_ind :
        forall (X : Type) (P : foo' X -&gt; Prop),
              (forall (l : list X) (f : foo' X),
                    <i>_____________________</i> -&gt;
                    <i>_____________________</i>   ) -&gt;
             <i>_________________________________________</i> -&gt;
             forall f : foo' X, <i>______________________</i>

<div class="paragraph"> </div>

 </div><div class="solution-text"><div>  foo'_ind : 
      forall (X : Type) (P : foo' X -&gt; Prop),
        (forall (l : list X) (f : foo' X),
           P f -&gt;
           P (C1 X l f)) -&gt;
        P (C2 X) -&gt;
        forall f : foo' X, P f
 </div></div><div class="doc"> 
<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab11"></a><h1 class="section">Induction Hypotheses</h1>

<div class="paragraph"> </div>

 Where does the phrase "induction hypothesis" fit into this story?

<div class="paragraph"> </div>

    The induction principle for numbers

<div class="paragraph"> </div>

       forall P : nat -&gt; Prop,
            P 0  -&gt;
            (forall n : nat, P n -&gt; P (S n))  -&gt;
            forall n : nat, P n

<div class="paragraph"> </div>

   is a generic statement that holds for all propositions
   <span class="inlinecode"><span class="id" title="var">P</span></span> (or rather, strictly speaking, for all families of
   propositions <span class="inlinecode"><span class="id" title="var">P</span></span> indexed by a number <span class="inlinecode"><span class="id" title="var">n</span></span>).  Each time we
   use this principle, we are choosing <span class="inlinecode"><span class="id" title="var">P</span></span> to be a particular
   expression of type <span class="inlinecode"><span class="id" title="var">nat</span>-&gt;<span class="id" title="keyword">Prop</span></span>.

<div class="paragraph"> </div>

   We can make proofs by induction more explicit by giving
   this expression a name.  For example, instead of stating
   the theorem <span class="inlinecode"><span class="id" title="var">mult_0_r</span></span> as "<span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">*</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>," we can
   write it as "<span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>", where <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> is defined
   as... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">P_m0r</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> * 0 = 0.<br/>

<br/>
</div>

<div class="doc">
... or equivalently: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">P_m0r'</span> : <span class="id" title="var">nat</span>-&gt;<span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">n</span> * 0 = 0.<br/>

<br/>
</div>

<div class="doc">
Now it is easier to see where <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> appears in the proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mult_0_r''</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P_m0r</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">P_m0r</span> <span class="id" title="tactic">in</span> <span class="id" title="var">IHn</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">P_m0r</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHn</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This extra naming step isn't something that we do in
    normal proofs, but it is useful to do it explicitly for an example
    or two, because it allows us to see exactly what the induction
    hypothesis is.  If we prove <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> by induction on
    <span class="inlinecode"><span class="id" title="var">n</span></span> (using either <span class="inlinecode"><span class="id" title="tactic">induction</span></span> or <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">nat_ind</span></span>), we see that the
    first subgoal requires us to prove <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode">0</span> ("<span class="inlinecode"><span class="id" title="var">P</span></span> holds for
    zero"), while the second subgoal requires us to prove <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>,</span>
    <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P_m0r</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> (that is "<span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> if it
    holds of <span class="inlinecode"><span class="id" title="var">n'</span></span>" or, more elegantly, "<span class="inlinecode"><span class="id" title="var">P</span></span> is preserved by <span class="inlinecode"><span class="id" title="var">S</span></span>").
    The <i>induction hypothesis</i> is the premise of this latter
    implication -- the assumption that <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">n'</span></span>, which we are
    allowed to use in proving that <span class="inlinecode"><span class="id" title="var">P</span></span> holds for <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h1 class="section">More on the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> Tactic</h1>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic actually does even more low-level
    bookkeeping for us than we discussed above.

<div class="paragraph"> </div>

    Recall the informal statement of the induction principle for
    natural numbers:
<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is some proposition involving a natural number n, and
        we want to show that P holds for <i>all</i> numbers n, we can
        reason like this:
<ul class="doclist">
<li> show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">O</span></span> holds

</li>
<li> show that, if <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> holds, then so does <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>

</li>
<li> conclude that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds for all n.

</li>
</ul>

</li>
</ul>
    So, when we begin a proof with <span class="inlinecode"><span class="id" title="tactic">intros</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> and then <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    we are first telling Coq to consider a <i>particular</i> <span class="inlinecode"><span class="id" title="var">n</span></span> (by
    introducing it into the context) and then telling it to prove
    something about <i>all</i> numbers (by using induction).

<div class="paragraph"> </div>

  What Coq actually does in this situation, internally, is to
    "re-generalize" the variable we perform induction on.  For
    example, in our original proof that <span class="inlinecode"><span class="id" title="var">plus</span></span> is associative... 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_assoc'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It also works to apply <span class="inlinecode"><span class="id" title="tactic">induction</span></span> to a variable that is
    quantified in the goal. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_comm'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span>].<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_O</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">intros</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Note that <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> leaves <span class="inlinecode"><span class="id" title="var">m</span></span> still bound in the goal --
    i.e., what we are proving inductively is a statement beginning
    with <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    If we do <span class="inlinecode"><span class="id" title="tactic">induction</span></span> on a variable that is quantified in the goal
    <i>after</i> some other quantifiers, the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic will
    automatically introduce the variables bound by these quantifiers
    into the context. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_comm''</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">m</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">m'</span>]. &nbsp;&nbsp;-  <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_O</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IHm'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h4 class="section">Exercise: 1 star, standard, optional (plus_explicit_prop)</h4>


<div class="paragraph"> </div>

    Rewrite both <span class="inlinecode"><span class="id" title="var">plus_assoc'</span></span> and <span class="inlinecode"><span class="id" title="var">plus_comm'</span></span> and their proofs in
    the same style as <span class="inlinecode"><span class="id" title="var">mult_0_r''</span></span> above -- that is, for each theorem,
    give an explicit <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> of the proposition being proved by
    induction, and state the theorem and proof in terms of this
    defined proposition.  
<div class="paragraph"> </div>

 </div><div class="solution"><div> 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">P_pa_</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> <span class="id" title="var">p</span>, <span class="id" title="var">n</span> + (<span class="id" title="var">m</span> + <span class="id" title="var">p</span>) = (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>) + <span class="id" title="var">p</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_assoc_</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>: <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P_pa_</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">unfold</span> <span class="id" title="var">P_pa_</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">unfold</span> <span class="id" title="var">P_pa_</span>. <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
</div></div><div class="doc"> 
<div class="paragraph"> </div>

 </div><div class="solution"><div> 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">P_pc_</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_comm_</span>: <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>: <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">P_pc_</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">unfold</span> <span class="id" title="var">P_pc_</span>. <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_O</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">unfold</span> <span class="id" title="var">P_pc_</span>. <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">plus_n_Sm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
</div></div><div class="doc"> 
<div class="paragraph"> </div>

 <font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab14"></a><h1 class="section">Induction Principles for Propositions</h1>

<div class="paragraph"> </div>

 Inductive definitions of propositions also cause Coq to generate
    induction priniciples.  For example, recall our proposition <span class="inlinecode"><span class="id" title="var">ev</span></span>,
    repeated here as <span class="inlinecode"><span class="id" title="var">ev''</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ev''</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">ev_0</span> : <span class="id" title="var">ev''</span> 0<br/>
| <span class="id" title="var">ev_SS</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">ev''</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">ev''</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">ev''_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ev''</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ev''</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
In English, <span class="inlinecode"><span class="id" title="var">ev''_ind</span></span> says: Suppose <span class="inlinecode"><span class="id" title="var">P</span></span> is a property of natural
    numbers.  To show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds whenever <span class="inlinecode"><span class="id" title="var">n</span></span> is even, it suffices
    to show:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> holds for <span class="inlinecode">0</span>,

<div class="paragraph"> </div>


</li>
<li> for any <span class="inlinecode"><span class="id" title="var">n</span></span>, if <span class="inlinecode"><span class="id" title="var">n</span></span> is even and <span class="inlinecode"><span class="id" title="var">P</span></span> holds for <span class="inlinecode"><span class="id" title="var">n</span></span>, then <span class="inlinecode"><span class="id" title="var">P</span></span>
        holds for <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. 
</li>
</ul>

<div class="paragraph"> </div>

 As expected, we can apply <span class="inlinecode"><span class="id" title="var">ev''_ind</span></span> directly instead of using
    <span class="inlinecode"><span class="id" title="tactic">induction</span></span>.  For example, we can use it to show that <span class="inlinecode"><span class="id" title="var">ev'</span></span> (the
    slightly awkward alternate definition of evenness that we saw in
    an exercise in the \chap{IndProp} chapter) is equivalent to the
    cleaner inductive definition <span class="inlinecode"><span class="id" title="var">ev''</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ev'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">ev'_0</span> : <span class="id" title="var">ev'</span> 0<br/>
| <span class="id" title="var">ev'_2</span> : <span class="id" title="var">ev'</span> 2<br/>
| <span class="id" title="var">ev'_sum</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> (<span class="id" title="var">Hn</span> : <span class="id" title="var">ev'</span> <span class="id" title="var">n</span>) (<span class="id" title="var">Hm</span> : <span class="id" title="var">ev'</span> <span class="id" title="var">m</span>) : <span class="id" title="var">ev'</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev''_ev'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev''</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">ev'</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev''_ind</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev'_0</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">Hm</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ev'_sum</span> 2 <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">ev'_2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The precise form of an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definition can affect the
    induction principle Coq generates. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">le1</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">le1_n</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">le1</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">le1_S</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, (<span class="id" title="var">le1</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) -&gt; (<span class="id" title="var">le1</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;m &lt;=1 n" := (<span class="id" title="var">le1</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>

<br/>
</div>

<div class="doc">
This definition can be streamlined a little by observing that the
    left-hand argument <span class="inlinecode"><span class="id" title="var">n</span></span> is the same everywhere in the definition,
    so we can actually make it a "general parameter" to the whole
    definition, rather than an argument to each constructor. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">le2</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">le2_n</span> : <span class="id" title="var">le2</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">le2_S</span> <span class="id" title="var">m</span> (<span class="id" title="var">H</span> : <span class="id" title="var">le2</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">le2</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;m &lt;=2 n" := (<span class="id" title="var">le2</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>

<br/>
</div>

<div class="doc">
The second one is better, even though it looks less symmetric.
    Why?  Because it gives us a simpler induction principle. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">le1_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=1 <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">n0</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=1 <span class="id" title="var">n0</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">n0</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">le2_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=2 <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n0</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=2 <span class="id" title="var">n0</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">n0</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab15"></a><h1 class="section">Another Form of Induction Principles on Propositions (Optional)</h1>

<div class="paragraph"> </div>

 The induction principle that Coq generated for <span class="inlinecode"><span class="id" title="var">ev''</span></span> was parameterized
    on a natural number <span class="inlinecode"><span class="id" title="var">n</span></span>.  It could have additionally been parameterized
    on the evidence that <span class="inlinecode"><span class="id" title="var">n</span></span> was even, which would have led to this
    induction principle:

<div class="paragraph"> </div>

    forall P : (forall n : nat, ev'' n -&gt; Prop),
      P O ev_0 -&gt;
      (forall (m : nat) (E : ev'' m),
        P m E -&gt; P (S (S m)) (ev_SS m E)) -&gt;
      forall (n : nat) (E : ev'' n), P n E

<div class="paragraph"> </div>

   ... because:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Since <span class="inlinecode"><span class="id" title="var">ev''</span></span> is indexed by a number <span class="inlinecode"><span class="id" title="var">n</span></span> (every <span class="inlinecode"><span class="id" title="var">ev''</span></span> object <span class="inlinecode"><span class="id" title="var">E</span></span> is
       a piece of evidence that some particular number <span class="inlinecode"><span class="id" title="var">n</span></span> is even),
       the proposition <span class="inlinecode"><span class="id" title="var">P</span></span> is parameterized by both <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">E</span></span> --
       that is, the induction principle can be used to prove
       assertions involving both an even number and the evidence that
       it is even.

<div class="paragraph"> </div>


</li>
<li> Since there are two ways of giving evidence of evenness (<span class="inlinecode"><span class="id" title="var">even</span></span>
       has two constructors), applying the induction principle
       generates two subgoals:

<div class="paragraph"> </div>

<ul class="doclist">
<li> We must prove that <span class="inlinecode"><span class="id" title="var">P</span></span> holds for <span class="inlinecode"><span class="id" title="var">O</span></span> and <span class="inlinecode"><span class="id" title="var">ev_0</span></span>.

<div class="paragraph"> </div>


</li>
<li> We must prove that, whenever <span class="inlinecode"><span class="id" title="var">m</span></span> is an even number and <span class="inlinecode"><span class="id" title="var">E</span></span>
           is an evidence of its evenness, if <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">m</span></span> and
           <span class="inlinecode"><span class="id" title="var">E</span></span>, then it also holds of <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> and <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">E</span></span>.

<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> If these subgoals can be proved, then the induction principle
       tells us that <span class="inlinecode"><span class="id" title="var">P</span></span> is true for <i>all</i> even numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and
       evidence <span class="inlinecode"><span class="id" title="var">E</span></span> of their evenness.

</li>
</ul>

<div class="paragraph"> </div>

    This is more flexibility than we normally need or want: it is
    giving us a way to prove logical assertions where the assertion
    involves properties of some piece of <i>evidence</i> of evenness, while
    all we really care about is proving properties of <i>numbers</i> that
    are even -- we are interested in assertions about numbers, not
    about evidence.  It would therefore be more convenient to have an
    induction principle for proving propositions <span class="inlinecode"><span class="id" title="var">P</span></span> that are
    parameterized just by <span class="inlinecode"><span class="id" title="var">n</span></span> and whose conclusion establishes <span class="inlinecode"><span class="id" title="var">P</span></span> for
    all even numbers <span class="inlinecode"><span class="id" title="var">n</span></span>:

<div class="paragraph"> </div>

       forall P : nat -&gt; Prop,
         ... -&gt;
       forall n : nat,
         even n -&gt; P n

<div class="paragraph"> </div>

    That is why Coq actually generates the induction principle
    <span class="inlinecode"><span class="id" title="var">ev''_ind</span></span> that we saw before. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab16"></a><h1 class="section">Formal vs. Informal Proofs by Induction</h1>

<div class="paragraph"> </div>

 Question: What is the relation between a formal proof of a
    proposition <span class="inlinecode"><span class="id" title="var">P</span></span> and an informal proof of the same proposition <span class="inlinecode"><span class="id" title="var">P</span></span>?

<div class="paragraph"> </div>

    Answer: The latter should <i>teach</i> the reader how to produce the
    former.

<div class="paragraph"> </div>

    Question: How much detail is needed??

<div class="paragraph"> </div>

    Unfortunately, there is no single right answer; rather, there is a
    range of choices.

<div class="paragraph"> </div>

    At one end of the spectrum, we can essentially give the reader the
    whole formal proof (i.e., the "informal" proof will amount to just
    transcribing the formal one into words).  This may give the reader
    the ability to reproduce the formal one for themselves, but it
    probably doesn't <i>teach</i> them anything much.

<div class="paragraph"> </div>

   At the other end of the spectrum, we can say "The theorem is true
   and you can figure out why for yourself if you think about it hard
   enough."  This is also not a good teaching strategy, because often
   writing the proof requires one or more significant insights into
   the thing we're proving, and most readers will give up before they
   rediscover all the same insights as we did.

<div class="paragraph"> </div>

   In the middle is the golden mean -- a proof that includes all of
   the essential insights (saving the reader the hard work that we
   went through to find the proof in the first place) plus high-level
   suggestions for the more routine parts to save the reader from
   spending too much time reconstructing these (e.g., what the IH says
   and what must be shown in each case of an inductive proof), but not
   so much detail that the main ideas are obscured.

<div class="paragraph"> </div>

   Since we've spent much of this chapter looking "under the hood" at
   formal proofs by induction, now is a good moment to talk a little
   about <i>informal</i> proofs by induction.

<div class="paragraph"> </div>

   In the real world of mathematical communication, written proofs
   range from extremely longwinded and pedantic to extremely brief and
   telegraphic.  Although the ideal is somewhere in between, while one
   is getting used to the style it is better to start out at the
   pedantic end.  Also, during the learning phase, it is probably
   helpful to have a clear standard to compare against.  With this in
   mind, we offer two templates -- one for proofs by induction over
   <i>data</i> (i.e., where the thing we're doing induction on lives in
   <span class="inlinecode"><span class="id" title="keyword">Type</span></span>) and one for proofs by induction over <i>evidence</i> (i.e.,
   where the inductively defined thing lives in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>). 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab17"></a><h2 class="section">Induction Over an Inductively Defined Set</h2>

<div class="paragraph"> </div>

 <i>Template</i>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: &lt;Universally quantified proposition of the form
         "For all <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">S</span></span>, <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span>," where <span class="inlinecode"><span class="id" title="var">S</span></span> is some inductively defined
         set.&gt;

<div class="paragraph"> </div>

         <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

           &lt;one case for each constructor <span class="inlinecode"><span class="id" title="var">c</span></span> of <span class="inlinecode"><span class="id" title="var">S</span></span>...&gt;

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">a1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">ak</span></span>, where &lt;...and here we state
             the IH for each of the <span class="inlinecode"><span class="id" title="var">a</span></span>'s that has type <span class="inlinecode"><span class="id" title="var">S</span></span>, if any&gt;.
             We must show &lt;...and here we restate <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="var">a1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">ak</span>)</span>&gt;.

<div class="paragraph"> </div>

             &lt;go on and prove <span class="inlinecode"><span class="id" title="var">P</span>(<span class="id" title="var">n</span>)</span> to finish the case...&gt;

<div class="paragraph"> </div>


</li>
<li> &lt;other cases similarly...&gt;                        <font size=-2>&#9744;</font>

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

    <i>Example</i>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: For all sets <span class="inlinecode"><span class="id" title="var">X</span></span>, lists <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>, and numbers
        <span class="inlinecode"><span class="id" title="var">n</span></span>, if <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> then <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>.

<div class="paragraph"> </div>

        <i>Proof</i>: By induction on <span class="inlinecode"><span class="id" title="var">l</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode">[]</span>.  We must show, for all numbers <span class="inlinecode"><span class="id" title="var">n</span></span>,
          that, if <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">[]</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, then <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">[]</span> <span class="inlinecode">=</span>
          <span class="inlinecode"><span class="id" title="var">None</span></span>.

<div class="paragraph"> </div>

          This follows immediately from the definition of <span class="inlinecode"><span class="id" title="var">index</span></span>.

<div class="paragraph"> </div>


</li>
<li> Suppose <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="var">l'</span></span> for some <span class="inlinecode"><span class="id" title="var">x</span></span> and <span class="inlinecode"><span class="id" title="var">l'</span></span>, where
          <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n'</span></span> implies <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> <span class="inlinecode"><span class="id" title="var">l'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">None</span></span>, for
          any number <span class="inlinecode"><span class="id" title="var">n'</span></span>.  We must show, for all <span class="inlinecode"><span class="id" title="var">n</span></span>, that, if
          <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode">(<span class="id" title="var">x</span>::<span class="id" title="var">l'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> then <span class="inlinecode"><span class="id" title="var">index</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">(<span class="id" title="var">x</span>::<span class="id" title="var">l'</span>)</span> <span class="inlinecode">=</span>
          <span class="inlinecode"><span class="id" title="var">None</span></span>.

<div class="paragraph"> </div>

          Let <span class="inlinecode"><span class="id" title="var">n</span></span> be a number with <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.  Since

<div class="paragraph"> </div>

            length l = length (x::l') = S (length l'),

<div class="paragraph"> </div>

          it suffices to show that

<div class="paragraph"> </div>

            index (S (length l')) l' = None.

<div class="paragraph"> </div>

          But this follows directly from the induction hypothesis,
          picking <span class="inlinecode"><span class="id" title="var">n'</span></span> to be <span class="inlinecode"><span class="id" title="var">length</span></span> <span class="inlinecode"><span class="id" title="var">l'</span></span>.  <font size=-2>&#9744;</font> 
</li>
</ul>

</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab18"></a><h2 class="section">Induction Over an Inductively Defined Proposition</h2>

<div class="paragraph"> </div>

 Since inductively defined proof objects are often called
    "derivation trees," this form of proof is also known as <i>induction
    on derivations</i>.

<div class="paragraph"> </div>

    <i>Template</i>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <i>Theorem</i>: &lt;Proposition of the form "<span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span>," where <span class="inlinecode"><span class="id" title="var">Q</span></span> is
         some inductively defined proposition (more generally,
         "For all <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>, <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>")&gt;

<div class="paragraph"> </div>

         <i>Proof</i>: By induction on a derivation of <span class="inlinecode"><span class="id" title="var">Q</span></span>.  &lt;Or, more
         generally, "Suppose we are given <span class="inlinecode"><span class="id" title="var">x</span></span>, <span class="inlinecode"><span class="id" title="var">y</span></span>, and <span class="inlinecode"><span class="id" title="var">z</span></span>.  We
         show that <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span> implies <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>, by induction on a
         derivation of <span class="inlinecode"><span class="id" title="var">Q</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span></span>"...&gt;

<div class="paragraph"> </div>

           &lt;one case for each constructor <span class="inlinecode"><span class="id" title="var">c</span></span> of <span class="inlinecode"><span class="id" title="var">Q</span></span>...&gt;

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose the final rule used to show <span class="inlinecode"><span class="id" title="var">Q</span></span> is <span class="inlinecode"><span class="id" title="var">c</span></span>.  Then
             &lt;...and here we state the types of all of the <span class="inlinecode"><span class="id" title="var">a</span></span>'s
             together with any equalities that follow from the
             definition of the constructor and the IH for each of
             the <span class="inlinecode"><span class="id" title="var">a</span></span>'s that has type <span class="inlinecode"><span class="id" title="var">Q</span></span>, if there are any&gt;.  We must
             show &lt;...and here we restate <span class="inlinecode"><span class="id" title="var">P</span></span>&gt;.

<div class="paragraph"> </div>

             &lt;go on and prove <span class="inlinecode"><span class="id" title="var">P</span></span> to finish the case...&gt;

<div class="paragraph"> </div>


</li>
<li> &lt;other cases similarly...&gt;                        <font size=-2>&#9744;</font>

</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

    <i>Example</i>

<ul class="doclist">
<li> <i>Theorem</i>: The <span class="inlinecode">&lt;=</span> relation is transitive -- i.e., for all
         numbers <span class="inlinecode"><span class="id" title="var">n</span></span>, <span class="inlinecode"><span class="id" title="var">m</span></span>, and <span class="inlinecode"><span class="id" title="var">o</span></span>, if <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">o</span></span>, then
         <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">o</span></span>.

<div class="paragraph"> </div>

         <i>Proof</i>: By induction on a derivation of <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">o</span></span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Suppose the final rule used to show <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">o</span></span> is
             <span class="inlinecode"><span class="id" title="var">le_n</span></span>. Then <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">o</span></span> and we must show that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
             which is immediate by hypothesis.

<div class="paragraph"> </div>


</li>
<li> Suppose the final rule used to show <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">o</span></span> is
             <span class="inlinecode"><span class="id" title="var">le_S</span></span>.  Then <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">o'</span></span> for some <span class="inlinecode"><span class="id" title="var">o'</span></span> with <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">o'</span></span>.
             We must show that <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">o'</span></span>.
             By induction hypothesis, <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">o'</span></span>.

<div class="paragraph"> </div>

             But then, by <span class="inlinecode"><span class="id" title="var">le_S</span></span>, <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">o'</span></span>.  <font size=-2>&#9744;</font> 
</li>
</ul>

</li>
</ul>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab19"></a><h1 class="section">Explicit Proof Objects for Induction (Optional)</h1>

<div class="paragraph"> </div>

 Although tactic-based proofs are normally much easier to
    work with, the ability to write a proof term directly is sometimes
    very handy, particularly when we want Coq to do something slightly
    non-standard.  
<div class="paragraph"> </div>

 Recall again the induction principle on naturals that Coq generates for
    us automatically from the Inductive declation for <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
There's nothing magic about this induction lemma: it's just
   another Coq lemma that requires a proof.  Coq generates the proof
   automatically too...  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">nat_ind</span>.<br/>

<br/>
</div>

<div class="doc">
We can rewrite that more tidily as follows: 
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">build_proof</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">evPO</span> : <span class="id" title="var">P</span> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">evPS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">evPO</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">k</span> =&gt; <span class="id" title="var">evPS</span> <span class="id" title="var">k</span> (<span class="id" title="var">build_proof</span> <span class="id" title="var">P</span> <span class="id" title="var">evPO</span> <span class="id" title="var">evPS</span> <span class="id" title="var">k</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_ind_tidy</span> := <span class="id" title="var">build_proof</span>.<br/>

<br/>
</div>

<div class="doc">
We can read <span class="inlinecode"><span class="id" title="var">build_proof</span></span> as follows: Suppose we have
    evidence <span class="inlinecode"><span class="id" title="var">evPO</span></span> that <span class="inlinecode"><span class="id" title="var">P</span></span> holds on 0, and evidence <span class="inlinecode"><span class="id" title="var">evPS</span></span> that <span class="inlinecode"><span class="id" title="keyword">forall</span></span>
    <span class="inlinecode"><span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>.  Then we can prove that <span class="inlinecode"><span class="id" title="var">P</span></span> holds of an
    arbitrary nat <span class="inlinecode"><span class="id" title="var">n</span></span> using recursive function <span class="inlinecode"><span class="id" title="var">build_proof</span></span>, which
    pattern matches on <span class="inlinecode"><span class="id" title="var">n</span></span>:

<div class="paragraph"> </div>

<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" title="var">n</span></span> is 0, <span class="inlinecode"><span class="id" title="var">build_proof</span></span> returns <span class="inlinecode"><span class="id" title="var">evPO</span></span> to show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>
        holds.

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode"><span class="id" title="var">n</span></span> is <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>, <span class="inlinecode"><span class="id" title="var">build_proof</span></span> applies itself recursively on
        <span class="inlinecode"><span class="id" title="var">k</span></span> to obtain evidence that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span> holds; then it applies
        <span class="inlinecode"><span class="id" title="var">evPS</span></span> on that evidence to show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> holds. 
</li>
</ul>

<div class="paragraph"> </div>

 Recursive function <span class="inlinecode"><span class="id" title="var">build_proof</span></span> thus pattern matches against
    <span class="inlinecode"><span class="id" title="var">n</span></span>, recursing all the way down to 0, and building up a proof
    as it returns. 
<div class="paragraph"> </div>

 The actual <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> that Coq generates uses a recursive
    function <span class="inlinecode"><span class="id" title="var">F</span></span> defined with <span class="inlinecode"><span class="id" title="keyword">fix</span></span> instead of <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>. 
<div class="paragraph"> </div>

  We can adapt this approach to proving <span class="inlinecode"><span class="id" title="var">nat_ind</span></span> to help prove
    <i>non-standard</i> induction principles too.  As a motivating example,
    suppose that we want to prove the following lemma, directly
    relating the <span class="inlinecode"><span class="id" title="var">ev</span></span> predicate we defined in <span class="inlinecode"><span class="id" title="var">IndProp</span></span>
    to the <span class="inlinecode"><span class="id" title="var">evenb</span></span> function defined in <span class="inlinecode"><span class="id" title="var">Basics</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">evenb_ev</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>: <span class="id" title="var">nat</span>, <span class="id" title="var">evenb</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">ev''</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
Attempts to prove this by standard induction on <span class="inlinecode"><span class="id" title="var">n</span></span> fail in the case for
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>,  because the induction hypothesis only tells us something about
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which is useless. There are various ways to hack around this problem;
    for example, we <i>can</i> use ordinary induction on <span class="inlinecode"><span class="id" title="var">n</span></span> to prove this (try it!):

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span> <span class="inlinecode"><span class="id" title="var">evenb_ev'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span>
     <span class="inlinecode">(<span class="id" title="var">evenb</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">/\</span> <span class="inlinecode">(<span class="id" title="var">evenb</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>.

<div class="paragraph"> </div>

    But we can make a much better proof by defining and proving a
    non-standard induction principle that goes "by twos":
 
</div>
<div class="code">

<br/>
&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_ind2</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span>(<span class="id" title="var">S</span> <span class="id" title="var">n</span>))) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> , <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">P0</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">P1</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">PSS</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) := <span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 =&gt; <span class="id" title="var">P0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; <span class="id" title="var">P1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) =&gt; <span class="id" title="var">PSS</span> <span class="id" title="var">n'</span> (<span class="id" title="var">f</span> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Once you get the hang of it, it is entirely straightforward to
     give an explicit proof term for induction principles like this.
     Proving this as a lemma using tactics is much less intuitive.

<div class="paragraph"> </div>

     The <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> tactic variant gives a convenient way to
     utilize a non-standard induction principle like this. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">evenb_ev</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">evenb</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> -&gt; <span class="id" title="var">ev''</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | |<span class="id" title="var">n'</span>] <span class="id" title="keyword">using</span> <span class="id" title="var">nat_ind2</span>.<br/>
&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>.<br/>
&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>
<div id="gitalk-container" style="margin: 30px;padding-bottom: 30px;"></div>
<script>
    var gitalk = new Gitalk({
        clientID: '2b012c6f83478a1bcd83',
        clientSecret: '90471bea7209d7e0c096ccd66358356712a31c94',
        repo: 'Software-Foundations-Solutions',
        owner: 'vbcpascal',
        admin: ['vbcpascal'],
        language: 'en',
    })
    gitalk.render('gitalk-container');
</script>

<div id="footer">
    <hr /><a href="coqindex.html">Index</a>
    <hr />This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</html>
